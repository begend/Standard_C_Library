什么是库

一，介绍
请写一个简单的“Hello World”程序，向终端输出这个字符串
很多人都会使用printf, cout, System.out.println
这代表了C，C++，Java的三种输出方式，它们都使用了各自语言的标准库函数
如果不使用标准库中的函数(putc, putchar, puts等等都不允许使用)怎么办呢？
这就是语言和库的关系

C语言的标准库是用C语言写的，printf使用了系统调用，库的作者完成了很多复杂的工作
最终向我们提供一个简单好用的函数接口，系统调用需要学习UNIX系统，比较底层而且困难
在早期UNIX用汇编语言开发，因此提供的系统调用也是汇编的接口
而现在系统调用则也是C函数，因此学习时相对方便一些
比如fopen函数是一个C标准库函数，使用它返回一个想要打开的文件指针FILE*
用户只需要使用这个FILE*指针即可，不用在乎FILE到底是什么
但实际上fopen内部需要使用系统调用stat(在UNIX环境下)
stat会打开一个文件，读取文件中的一段内容到一个buffer缓冲区中(实际就是一段数组)
然后供后续的读写操作，等等
当我们在另一个系统比如Windows下使用fopen函数时，这个stat系统调用也许就变成了另一个
但是标准库提供的fopen函数的接口是不变的，实现的原则也大同小异
但细节需要一些变化，这也是经常听说的代码移植
而这个不变的原则也正是这个库为什么被成为标准库的原因
就像工业生产的机械一样，有了标准才能进行大型的工业生产

通过学习库函数，可以设计出复用性好的库，自己来编写自己项目的库

二，库的三条重要属性
1，幂等性
多次重复包含某个头文件的效果等效于包含一次头文件
2，独立性
库之间相互独立，一个库不会依赖另一个库
3，声明等价性
库与源码等效

三，库的实现
实际看看那些头文件stdio.h等等，会发现其实里面没有函数实现
所以根本无法找到printf函数到底是怎么实现的，而只能看到类似于
extern int printf(......)
这样的函数声明，也就是说printf函数在别的文件中被编写好，而只在头文件中声明
真正的库函数就是一些已经编辑好的 extern 函数加上库中的宏定义组合在一起的
比如assert实际是一个宏，它实际调用了assert_perror加一些其他的函数
而assert_perror函数声明为 extern，实际上这些函数已经编译好放在操作系统的链接库中
编译器在编译程序员的源文件时通过库的一些定义
将程序员源文件和操作系统的链接库链接在一起组成
而assert_perror函数的实现则需要调用一些操作系统级别的系统调用函数来完成
linux系统中头文件在/usr/include下，链接库在/usr/lib下
这些链接库都是动态链接库.so文件
将最简单的main(){ printf("HelloWorld\n"); }程序编译链接为一个可执行程序main后
用vim打开main，可以看到其中都是乱码
但在这些乱码中仍然可以看到一些简单的英文字符串，比如libc.so这样的字样
没错，libc.so就是printf函数真正所在动态链接
生成的main中实际信息是调用libc.so中的printf来完成终端输出工作的
而并没有将printf的源码加进main中，当运行main时程序会自动找到libc.so中的函数运行
这也是动态链接的特性，如果加进来就是静态链接，静态链接是一个过时的技术


